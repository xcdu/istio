  Istio provides the ability to configure advanced tracing options, such as sampling rate and adding custom tags to reported spans. Sampling is a beta feature, but adding custom tags and tracing tag length are considered in-development for this release.Ensure that your applications propagate tracing headers as described .Follow the tracing installation guide located under based on your preferred tracing backend to install the appropriate addon and configure your Istio proxies to send traces to the tracing deployment.You can configure the following tracing options in Istio:Random sampling rate for percentage of requests that will be selected for trace generation.Maximum length of the request path after which the path will be truncated for reporting. This can be useful in limiting trace data storage specially if you’re collecting traces at ingress gateways.Adding custom tags in spans. These tags can be added based on static literal values, environment values or fields from request headers. This can be used to inject additional information in spans specific to your environment.There are two ways you can configure tracing options:Globally via  options.Per pod annotations for workload specific customization.Note that any pod annotations added for tracing configuration overrides global settings. In order to preserve any global settings you should copy them from global mesh config to pod annotations along with workload specific customization. In particular, make sure that the tracing backend address is always provided in the annotations to ensure that the traces are reported correctly for the workload.All tracing options can be configured globally via . To simplify configuration, it is recommended to create a single YAML file which you can pass to the  command.You can add the  annotation to your Pod metadata specification to override any mesh-wide tracing settings. For instance, to modify the  deployment shipped with Istio you would add the following to :The sampling rate option can be used to control what percentage of requests get reported to your tracing system. This should be configured depending upon your traffic in the mesh and the amount of tracing data you want to collect. The default rate is 1%.Previously, the recommended method was to change the setting during the mesh setup or to change the environment variable in the pilot or istiod deployment. While this method to alter sampling continues to work, the following method is strongly recommended instead.In the event that both are specified, the value specified in the  will override any other setting.To modify the default random sampling to 50, add the following option to your file.The sampling rate should be in the range of 0.0 to 100.0 with a precision of 0.01. For example, to trace 5 requests out of every 10000, use 0.05 as the value here.Custom tags can be added to spans based on literals, environmental variables and client request headers in order to provide additional information in spans specific to your environment.You can customize the tags using any of the three supported options below.Literal represents a static value that gets added to each span.Environmental variables can be used where the value of the custom tag is populated from a workload proxy environment variable.Client request header option can be used to populate tag value from an incoming client request header.By default, the maximum length for the request path included as part of the  span tag is 256. To modify this maximum length, add the following to your  file.Learn how to configure the proxies to send tracing requests to Jaeger.How to configure the proxies to send tracing requests to Lightstep.Overview of distributed tracing in Istio.This task shows you how to configure external access to the set of Istio telemetry addons.Learn how to configure the proxies to send tracing requests to Zipkin.A new way to manage installation of telemetry addons.Istio 1.8© 2020 Istio Authors, Page last modified: August 11, 2020  This task shows you how to configure Istio to collect trace spans and send them to . Lightstep lets you analyze 100% of unsampled transaction data from large-scale production software to produce meaningful distributed traces and metrics that help explain performance behaviors and accelerate root cause analysis. At the end of this task, Istio sends trace spans from the proxies to a Lightstep Satellite pool making them available to the web UI.This task uses the  sample application as an example.Ensure you have a Lightstep account.  for a free trial of Lightstep.If you’re using , ensure you have a satellite pool configured with TLS certs and a secure GRPC port exposed. See for details about setting up satellites.For  or , your satellites are already configured.Ensure sure you have a Lightstep . Access tokens allow your app to communicate with your Lightstep project.You’ll need to deploy Istio with your satellite address. For on-premise Satellites, ensure you can reach the satellite pool at an address in the format , for example .For for Public or Developer Satellites, use the address .Deploy Istio with the following configuration parameters specified:You can set these parameters using the  syntax when you run the install command. For example:Store your satellite pool’s certificate authority certificate as a secret in the default namespace. For Lightstep Public and Developer Satellites, download and use . If you deploy the Bookinfo application in a different namespace, create the secret in that namespace instead.Follow the .Follow the .To verify the previous step’s success, confirm that you set  environment variable in your shell.Send traffic to the sample application.Load the Lightstep . You’ll see the three Bookinfo services listed in the Service Directory.Navigate to the Explorer view.Find the query bar at the top. The query bar allows you to interactively filter results by a , , and  values.Select  from the  drop-down list.Click . You see something similar to the following:Click on the first row in the table of example traces below the latency histogram to see the details corresponding to your refresh of the . The page then looks similar to:The screenshot shows that the trace is comprised of a set of spans. Each span corresponds to a Bookinfo service invoked during the execution of a  request.Two spans in the trace represent every RPC. For example, the call from  to  starts with the span labeled with the  operation and the service. This service represents the client-side span of the call. The screenshot shows that the call took 15.30 ms. The second span is labeled with the  operation and the  service. The second span is a child of the first span and represents the server-side span of the call. The screenshot shows that the call took 14.60 ms.Istio captures traces at a configurable trace sampling percentage. To learn how to modify the trace sampling percentage, visit the .When using Lightstep, we do not recommend reducing the trace sampling percentage below 100%. To handle a high traffic mesh, consider scaling up the size of your satellite pool.If you are not planning any follow-up tasks, remove the Bookinfo sample application and any Lightstep secrets from your cluster.To remove the Bookinfo application, refer to the  instructions.Remove the secret generated for Lightstep:How to configure tracing options (beta/development).Learn how to configure the proxies to send tracing requests to Jaeger.Overview of distributed tracing in Istio.This task shows you how to configure external access to the set of Istio telemetry addons.Learn how to configure the proxies to send tracing requests to Zipkin.A new way to manage installation of telemetry addons.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task shows how to configure Istio to expose and access the telemetry addons outside of a cluster.Remote access to the telemetry addons can be configured in a number of different ways. This task covers two basic access methods: secure (via HTTPS) and insecure (via HTTP). The secure method is  for any production or sensitive environment. Insecure access is simpler to set up, but will not protect any credentials or data transmitted outside of your cluster.For both options, first follow these steps: in your cluster.To additionally install the telemetry addons, follow the  documentation.Set up the domain to expose addons. In this example, you expose each addon on a subdomain, such as .A server certificate is required for secure access. Follow these steps to install and configure server certificates for a domain that you control.This example uses self-signed certificates, which may not be appropriate for production usages. For these cases, consider using  or other tools to provision certificates. You may also visit the  task for general information on using HTTPS on the gateway.Setup the certificates. This example uses  to self sign.Apply networking configuration for the telemetry addons.Apply the following configuration to expose Grafana:Apply the following configuration to expose Kiali:Apply the following configuration to expose Prometheus:Apply the following configuration to expose the tracing service:Visit the telemetry addons via your browser.Apply networking configuration for the telemetry addons.Apply the following configuration to expose Grafana:Apply the following configuration to expose Kiali:Apply the following configuration to expose Prometheus:Apply the following configuration to expose the tracing service:Visit the telemetry addons via your browser.Remove all related Gateways:Remove all related Virtual Services:Remove all related Destination Rules:A new way to manage installation of telemetry addons.Learn how to configure the proxies to send tracing requests to Jaeger.Learn how to configure the proxies to send tracing requests to Zipkin.How to configure tracing options (beta/development).How to integrate with Jaeger.How to configure the proxies to send tracing requests to Lightstep.Istio 1.8© 2020 Istio Authors, Page last modified: October 26, 2020  The simplest kind of Istio logging is . Envoy proxies print access information to their standard output. The standard output of Envoy’s containers can then be printed by the  command.Setup Istio by following the instructions in the .Deploy the  sample app to use as a test source for sending requests. If you have  enabled, run the following command to deploy the sample app:Otherwise, manually inject the sidecar before deploying the  application with the following command:Set the  environment variable to the name of your source pod:Start the  sample.If you have enabled , deploy the  service:Otherwise, you have to manually inject the sidecar before deploying the  application:If you used an  CR to install Istio, add the following field to your configuration:Otherwise, add the equivalent setting to your original  command, for example:You can also choose between JSON and text by setting  to  or .You may also want to customize the of the access log by editing .Refer to  for more information on all three of these settings:Send a request from  to :Check ’s log:Check ’s log:Note that the messages corresponding to the request appear in logs of the Istio proxies of both the source and the destination,  and , respectively. You can see in the log the HTTP verb (), the HTTP path (), the response code () and other .Shutdown the  and  services:Remove, or set to , the  setting in your Istio install configuration.A new way to manage installation of telemetry addons.Improving availability and reducing latency.Provides an overview of Mixer's plug-in architecture.This task shows you how to improve telemetry by grouping requests and responses by their type.This task shows you how to configure Istio to collect metrics for TCP services.How to configure tracing options (beta/development).Istio 1.8© 2020 Istio Authors, Page last modified: October 30, 2020  It’s useful to visualize telemetry based on the type of requests and responses handled by services in your mesh. For example, a bookseller tracks the number of times book reviews are requested. A book review request has this structure:Counting the number of review requests must account for the unbounded element .  followed by  should count as two requests to get reviews.Istio lets you create classification rules using the that groups requests into a fixed number of logical operations. For example, you can create an operation named , which is a common way to identify operations using the . This information is injected into request processing as  attribute with value equal to . You can use the attribute as a dimension in Istio standard metrics. Similarly, you can track metrics based on other operations like  and .For more information, see the .Istio uses the Envoy proxy to generate metrics and provides its configuration in the  at . As a result, writing classification rules involves adding attributes to the .You can classify requests based on their type, for example , , .Create a file, for example , and save it with the following contents. This adds the  plugin to the . It also creates an attribute,  and populates it with values for the categories to count as metrics.This configuration is service-specific since request paths are typically service-specific.Apply your changes using the following command:Find the   resource from the namespace, using the following command:Create a local file system copy of the  configuration, using the following command:Open  with a text editor and locate the extension configuration. Update it to map dimension in the  standard metric to  attribute. The updated configuration file section should look like the following.Save  and then apply the configuration using the following command:Generate metrics by sending traffic to your application.After the changes take effect, visit Prometheus and look for the new or changed dimensions, for example .You can classify responses using a similar process as requests.Create a file, for example , and save it with the following contents. This add the  plugin to the and generates the  attribute used by the stats plugin.This example classifies various responses, such as grouping all response codes in the  range as a  dimension.Apply your changes using the following command:Find the   resource from the namespace, using the following command:Create a local file system copy of the  configuration, using the following command:Open  with a text editor and locate the extension configuration. Update it to map dimension in the  standard metric to  attribute. The updated configuration file section should look like the following.Save  and then apply the configuration using the following command:Generate metrics by sending traffic to your application.Visit Prometheus and look for the new or changed dimensions, for example . Alternatively, use the following command to verify that Istio generates the data for your new dimension:In the output, locate the metric (e.g. ) and verify the presence of the new or changed dimension.If classification does not occur as expected, check the following potential causes and resolutions.Review the Envoy proxy logs for the pod that has the service on which you applied the configuration change. Check that there are no errors reported by the service in the Envoy proxy logs on the pod, (), where you configured classification by using the following command:Additionally, ensure that there are no Envoy proxy crashes by looking for signs of restarts in the output of the following command:This task shows you how to configure Istio to collect metrics for TCP services.This task shows you how to customize the Istio metrics.This task shows you how to query for Istio Metrics using Prometheus.A new way to manage installation of telemetry addons.Improving availability and reducing latency.Provides an overview of Mixer's plug-in architecture.Istio 1.8© 2020 Istio Authors, Page last modified: November 4, 2020  This task shows you how to customize the metrics that Istio generates.Istio generates telemetry that various dashboards consume to help you visualize your mesh. For example, dashboards that support Istio include:By default, Istio defines and generates a set of standard metrics (e.g. ), but you can also customize them and create new metrics.Istio uses the Envoy proxy to generate metrics and provides its configuration in the  at .Configuring custom statistics involves two sections of the :  and . The  section supports creating new metrics by name, the expected value expression, and the metric type (, , and ). The  section provides values for the metric dimensions as expressions, and allows you to remove or override the existing metric dimensions. You can modify the standard metric definitions using  or by re-defining a dimension. These configuration settings are also exposed as istioctl installation options, which allow you to customize different metrics for gateways and sidecars as well as for the inbound or outbound direction.For more information, see . in your cluster and deploy an application. Alternatively, you can set up custom statistics as part of the Istio installation.The  sample application is used as the example application throughout this task.The default telemetry v2  configuration is equivalent to the following installation options:To customize telemetry v2 metrics, for example, to add and  dimensions to the  metric emitted by both gateways and sidecars in the inbound and outbound direction, change the installation options as follows:Apply the following annotation to all injected pods with the list of the dimensions to extract into a Prometheus using the following command:To enable extra tags mesh wide, you can add  to your mesh config:Send traffic to the mesh. For the Bookinfo sample, visit  in your web browser or issue the following command:Use the following command to verify that Istio generates the data for your new or modified dimensions:For example, in the output, locate the metric  and verify it contains your new dimension.The values in the metric configuration are common expressions, which means you must double-quote strings in JSON, e.g. “‘string value’”. Unlike Mixer expression language, there is no support for the pipe () operator, but you can emulate it with the  or  operator, for example:For more information, see .Istio exposes all standard . Peer metadata is available as attributes  for outbound and  for inbound with the following fields:For example, the expression for the peer  label to be used in an outbound configuration is .For more information, see .This task shows you how to improve telemetry by grouping requests and responses by their type.This task shows you how to configure Istio to collect metrics for TCP services.This task shows you how to query for Istio Metrics using Prometheus.A new way to manage installation of telemetry addons.Improving availability and reducing latency.Provides an overview of Mixer's plug-in architecture.Istio 1.8© 2020 Istio Authors, Page last modified: November 16, 2020  This task shows you how to set up Istio authorization policy that denies HTTP traffic in an Istio mesh. Learn more in our .Before tackling this task you must perform the following actions:Read the .Follow the  to install Istio.Deploy workloads:This task uses two workloads, httpbin and sleep, deployed on one namespace, foo. Both workloads run with an Envoy proxy in front of each. Deploy the example namespace and workloads with the following command:Verify that  talks to  with the following command:The following command creates the  authorization policy for the  workload in the  namespace. The policy sets the  to  to deny requests that satisfy the conditions set in the  section. This type of policy is better known as deny policy. In this case, the policy denies requests if their method is .Verify that  requests are denied:Verify that  requests are allowed:Update the  authorization policy to deny  requests only if the value of the HTTP header  value is not . The following example policy sets the value of the  field to  to deny requests with a header value that is not :Verify that  requests with the HTTP header  are allowed:Verify that GET requests with the HTTP header  are denied:The following command creates the  authorization policy to allow requests at the  path to the  workload. This authorization policy sets the  field to . This type of policy is better known as an allow policy.Verify that  requests with the HTTP header  at path  are denied by the  policy. Deny policies takes precedence over the allow policies:Verify that  requests with the HTTP header  at path  are allowed by the  policy:Verify that  requests with the HTTP header  at path  are denied because they don’t match the  policy:Remove the namespace foo from your configuration:Shows how to migrate from one trust domain to another without changing authorization policy.Shows how to set up access control for HTTP traffic.How to set up access control for TCP traffic.How to set up access control on an ingress gateway.Describes Istio's authorization and authentication functionality.Describe Istio's authorization feature and how to use it in various use cases.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task shows you how to set up Istio authorization for HTTP traffic in an Istio mesh. Learn more in our .The activities in this task assume that you:Read the .Follow the  to install Istio with mutual TLS enabled.Deploy the  sample application.After deploying the Bookinfo application, go to the Bookinfo product page at . On the product page, you can see the following sections:When you refresh the page, the app shows different versions of reviews in the product page. The app presents the reviews in a round robin style: red stars, black stars, or no stars.Using Istio, you can easily setup access control for in your mesh. This task shows you how to set up access control using Istio authorization. First, you configure a simple  policy that rejects all requests to the workload, and then grant more access to the workload gradually and incrementally.Run the following command to create a  policy in the  namespace. The policy doesn’t have a  field, which applies the policy to every workload in the namespace. The  field of the policy has the empty value . That value means that no traffic is permitted, effectively denying all requests.Point your browser at the Bookinfo  (). You should see . The error shows that the configured  policy is working as intended, and Istio doesn’t have any rules that allow any access to workloads in the mesh.Run the following command to create a  policy to allow access with  method to the  workload. The policy does not set the field in the  which means all sources are allowed, effectively allowing all users and workloads:Point your browser at the Bookinfo  (). Now you should see the “Bookinfo Sample” page. However, you can see the following errors on the page:These errors are expected because we have not granted the workload access to the  and  workloads. Next, you need to configure a policy to grant access to those workloads.Run the following command to create the  policy to allow the workload, which issues requests using the service account, to access the  workload through  methods:Run the following command to create a policy  to allow the  workload, which issues requests using the  service account, to access the  workload through  methods:Point your browser at the Bookinfo  (). Now, you should see the “Bookinfo Sample” page with “Book Details” on the lower left part, and “Book Reviews” on the lower right part. However, in the “Book Reviews” section, there is an error .This is because the  workload doesn’t have permission to access the  workload. To fix this issue, you need to grant the  workload access to the  workload. Next, we configure a policy to grant the  workload that access.Run the following command to create the  policy to allow the  workload, which issues requests using the  service account, to access the  workload through  methods:Point your browser at the Bookinfo  (). You should see the “black” and “red” ratings in the “Book Reviews” section. You successfully applied authorization policy to enforce access control for workloads using HTTP traffic.Remove all authorization policies from your configuration:Shows how to migrate from one trust domain to another without changing authorization policy.How to set up access control for TCP traffic.How to set up access control on an ingress gateway.Shows how to set up access control to deny traffic explicitly.Describes Istio's authorization and authentication functionality.Describe Istio's authorization feature and how to use it in various use cases.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task shows you how to enforce IP-based access control on an Istio ingress gateway using an authorization policy.Before you begin this task, do the following:Read the .Install Istio using the .Deploy a workload,  in a namespace, for example , and expose it through the Istio ingress gateway with this command:Turn on RBAC debugging in Envoy for the ingress gateway:Follow the instructions in  to define the  and  environment variables.Verify that the  workload and ingress gateway are working as expected using this command:All methods of getting traffic into Kubernetes involve opening a port on all worker nodes. The main features that accomplish this are the  service and the  service. Even the Kubernetes  resource must be backed by an Ingress controller that will create either a  or a  service.A  just opens up a port in the range 30000-32767 on each worker node and uses a label selector to identify which Pods to send the traffic to. You have to manually create some kind of load balancer in front of your worker nodes or use Round-Robin DNS.A  is just like a , except it also creates an environment specific external load balancer to handle distributing traffic to the worker nodes. For example, in AWS EKS, the  service will create a Classic ELB with your worker nodes as targets. If your Kubernetes environment does not have a  implementation, then it will just behave like a . An Istio ingress gateway creates a  service.What if the Pod that is handling traffic from the  or  isn’t running on the worker node that received the traffic? Kubernetes has its own internal proxy called kube-proxy that receives the packets and forwards them to the correct node.If a packet goes through an external proxy load balancer and/or kube-proxy, then the original source IP address of the client is lost. Below are some strategies for preserving the original client IP for logging or security purposes.A critical  has been identified in Envoy that the proxy protocol downstream address is restored incorrectly for non-HTTP connections.Please DO NOT USE the  field and  attribute with proxy protocol on non-HTTP connections until a newer version of Istio is released with a proper fix.Note that Istio doesn’t support the proxy protocol and it can be enabled only with the  API and should be used at your own risk.If you are using a TCP/UDP Proxy external load balancer (AWS Classic ELB), it can use the  to embed the original client IP address in the packet data. Both the external load balancer and the Istio ingress gateway must support the proxy protocol for it to work. In Istio, you can enable it with an  like below:Here is a sample of the  that shows how to configure the Istio ingress gateway on AWS EKS to support the Proxy Protocol:If you are using a TCP/UDP network load balancer that preserves the client IP address (AWS Network Load Balancer, GCP External Network Load Balancer, Azure Load Balancer) or you are using Round-Robin DNS, then you can also preserve the client IP inside Kubernetes by bypassing kube-proxy and preventing it from sending traffic to other nodes.  If you don’t, then any node that receives traffic and doesn’t have an ingress gateway will drop the traffic. See for more information. Update the ingress gateway to set  to preserve the original client source IP on the ingress gateway using the following command:If you are using an HTTP/HTTPS external load balancer (AWS ALB, GCP ), it can put the original client IP address in the X-Forwarded-For header. Istio can extract the client IP address from this header with some configuration. See . Quick example if using a single load balancer in front of Kubernetes:For reference, here are the types of load balancers created by Istio with a  service on popular managed Kubernetes environments:You can instruct AWS EKS to create a Network Load Balancer when you install Istio by using a  like below: If you are using the X-Forwarded-For HTTP header or the Proxy Protocol to determine the original client IP address, then you should use  in your . If you are using , then you should use  in your .Create the AuthorizationPolicy:Verify that a request to the ingress gateway is denied:Update the  to include your client IP address:Find your original client IP address if you don’t know it and assign it to a variable:Find your original client IP address if you don’t know it and assign it to a variable:Create the AuthorizationPolicy:Verify that a request to the ingress gateway is allowed:Update the  authorization policy to set the  key to  so that the IP addresses specified in the  are not allowed to access the ingress gateway:Verify that a request to the ingress gateway is denied:You could use an online proxy service to access the ingress gateway using a different client IP to verify the request is allowed.If you are not getting the responses you expect, view the ingress gateway logs which should show RBAC debugging information:Remove the namespace :Remove the authorization policy:Shows how to migrate from one trust domain to another without changing authorization policy.Shows how to set up access control for HTTP traffic.How to set up access control for TCP traffic.Shows how to set up access control to deny traffic explicitly.Describes Istio's authorization and authentication functionality.Describe Istio's authorization feature and how to use it in various use cases.Istio 1.8© 2020 Istio Authors, Page last modified: November 20, 2020  This task shows you how to set up an Istio authorization policy to enforce access based on a JSON Web Token (JWT). An Istio authorization policy supports both string typed and list-of-string typed JWT claims.Before you begin this task, perform the following actions:Read  and .Install Istio using .Deploy two workloads:  and . Deploy these in one namespace, for example . Both workloads run with an Envoy proxy in front of each. Deploy the example namespace and workloads using these commands:Verify that  successfully communicates with  using this command:The following command creates the  request authentication policy for the  workload in the  namespace. This policy for  workload accepts a JWT issued by :Verify that a request with an invalid JWT is denied:Verify that a request without a JWT is allowed because there is no authorization policy:The following command creates the  authorization policy for the  workload in the  namespace. The policy requires all requests to the  workload to have a valid JWT with set to . Istio constructs the  by combining the  and  of the JWT token with a  separator as shown:Get the JWT that sets the  and  keys to the same value, . This causes Istio to generate the attribute  with the value :Verify that a request with a valid JWT is allowed:Verify that a request without a JWT is denied:The following command updates the  authorization policy to also require the JWT to have a claim named  containing the value :Get the JWT that sets the  claim to a list of strings:  and :Verify that a request with the JWT that includes  in the  claim is allowed:Verify that a request with a JWT, which doesn’t have the  claim is rejected:Remove the namespace :Introduction, motivation and design principles for the Istio v1beta1 Authorization Policy.Using Istio to secure multi-cloud Kubernetes applications with zero code changes.Describe Istio's authorization feature and how to use it in various use cases.Shows how to migrate from one trust domain to another without changing authorization policy.Shows how to set up access control for HTTP traffic.How to set up access control for TCP traffic.Istio 1.8© 2020 Istio Authors, Page last modified: September 14, 2020  This task shows you how to set up Istio authorization for TCP traffic in an Istio mesh.Before you begin this task, do the following:Read the .Install Istio using the .Deploy two workloads named  and  together in a namespace, for example . Both workloads run with an Envoy proxy in front of each. The  workload listens on port 9000, 9001 and 9002 and echoes back any traffic it received with a prefix . For example, if you send “world” to , it will reply with . The  Kubernetes service object only declares the ports 9000 and 9001, and omits the port 9002. A pass-through filter chain will handle port 9002 traffic. Deploy the example namespace and workloads using the following command:Verify that  successfully communicates with on ports 9000 and 9001 using the following command:Verify that  successfully communicates with  on port 9002. You need to send the traffic directly to the pod IP of  because the port 9002 is not defined in the Kubernetes service object of . Get the pod IP address and send the request with the following command:Create the  authorization policy for the  workload in the  namespace. Run the following command to apply the policy to allow requests to port 9000 and 9001:Verify that requests to port 9000 are allowed using the following command:Verify that requests to port 9001 are allowed using the following command:Verify that requests to port 9002 are denied. This is enforced by the authorization policy which also applies to the pass through filter chain, even if the port is not declared explicitly in the  Kubernetes service object. Run the following command and verify the output:Update the policy to add an HTTP-only field named  for port 9000 using the following command:Verify that requests to port 9000 are denied. This occurs because the rule becomes invalid when it uses an HTTP-only field () for TCP traffic. Istio ignores the invalid ALLOW rule. The final result is that the request is rejected, because it does not match any ALLOW rules. Run the following command and verify the output:Verify that requests to port 9001 are denied. This occurs because the requests do not match any ALLOW rules. Run the following command and verify the output:Update the policy to a DENY policy using the following command:Verify that requests to port 9000 are denied. This occurs because Istio ignores the HTTP-only fields in an invalid DENY rule. This is different from an invalid ALLOW rule, which causes Istio to ignore the entire rule. The final result is that only the field is used by Istio and the requests are denied because they match with the :Verify that requests to port 9001 are allowed. This occurs because the requests do not match the  in the DENY policy:Remove the namespace foo:Shows how to migrate from one trust domain to another without changing authorization policy.Shows how to set up access control for HTTP traffic.How to set up access control on an ingress gateway.Shows how to set up access control to deny traffic explicitly.Describes Istio's authorization and authentication functionality.Describe Istio's authorization feature and how to use it in various use cases.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task shows you how to migrate from one trust domain to another without changing authorization policy.In Istio 1.4, we introduce an alpha feature to support  for authorization policy. This means if an Istio mesh needs to change its , the authorization policy doesn’t need to be changed manually. In Istio, if a  is running in namespace  with the service account , and the trust domain of the system is , the identity of said workload is . By default, the Istio mesh trust domain is , unless you specify it during the installation.Read the .Install Istio with a custom trust domain and mutual TLS enabled.Deploy the  sample in the  namespace and the  sample in the  and  namespaces:Apply the authorization policy below to deny all requests to  except from  in the  namespace.Notice that it may take tens of seconds for the authorization policy to be propagated to the sidecars.Verify that requests to  from:Install Istio with a new trust domain.Redeploy istiod to pick up the trust domain changes.Istio mesh is now running with a new trust domain, .Redeploy the  and  applications to pick up changes from the new Istio control plane.Verify that requests to  from both  in  namespace and  namespace are denied.This is because we specified an authorization policy that deny all requests to , except the ones the  identity, which is the old identity of the  application in  namespace. When we migrated to a new trust domain above, i.e. , the identity of this  application is now , which is not the same as . Therefore, requests from the  application in  namespace to  were allowed before are now being denied. Prior to Istio 1.4, the only way to make this work is to change the authorization policy manually. In Istio 1.4, we introduce an easy way, as shown below.Install Istio with a new trust domain and trust domain aliases.Without changing the authorization policy, verify that requests to  from:Starting from Istio 1.4, when writing authorization policy, you should consider using the value  as the trust domain part in the policy. For example, instead of , it should be . Notice that in this case,  is not the Istio mesh trust domain (the trust domain is still ). However, in authorization policy,  is a pointer that points to the current trust domain, i.e.  (and later ), as well as its aliases. By using  in the authorization policy, when you migrate to a new trust domain, Istio will detect this and treat the new trust domain as the old trust domain without you having to include the aliases.Shows how to set up access control for HTTP traffic.How to set up access control for TCP traffic.How to set up access control on an ingress gateway.Shows how to set up access control to deny traffic explicitly.Describes Istio's authorization and authentication functionality.Describe Istio's authorization feature and how to use it in various use cases.Istio 1.8© 2020 Istio Authors, Page last modified: November 11, 2020  This feature requires Kubernetes version >= 1.18.This task shows how to provision Workload Certificates using a custom certificate authority that integrates with the . This feature leverages , a lightweight component linked with Istiod that signs certificates using the Kubernetes CSR API.This task is split into two parts. The first part demonstrates how to use the Kubernetes CA itself to sign workload certificates. The second part demonstrates how to use a custom CA that integrates with the Kubernetes CSR API to sign your certificates.Deploy Istio on the cluster using  with the following configuration.Deploy the  sample application in the bookinfo namespace. Ensure that the following commands are executed in the Istio root directory.When the workloads are deployed, above, they send CSR Requests to Istiod which forwards them to the Kubernetes CA for signing. If all goes well, the signed certificates are sent back to the workloads where they are then installed. To verify that they have been signed by the Kubernetes CA, you need to first extract the signed certificates.Dump all pods running in the namespace.Pick any one of the running pods for the next step.Get the certificate chain and CA root certificate used by the Istio proxies for mTLS.The proxy_secret json file contains the CA root certificate for mTLS in the  field. Note that this certificate is base64 encoded.The certificate used by the Kubernetes CA (specifically the  signer) is loaded onto the secret associated with every service account in the bookinfo namespace.Pick a secret-name that is associated with any of the service-accounts. These have a “token” in their name.The  field in the output contains the base64 encoded Kubernetes CA certificate.Compare the  obtained in the previous step with the contents of the  field in the step before. These two should be the same.(Optional) Follow the rest of the steps in the  to ensure that communication between services is working as expected.Remove the  and  namespaces:This assumes that the custom CA implements a controller that has the necessary permissions to read and sign Kubernetes CSR Requests. Refer to the  for more details. Note that the steps below are dependent on an external-source and may change.For this example, we use an . This code builds a controller that reads the CSR resources on the Kubernetes cluster and creates certificates using local keys. Follow the instructions on the page to:Deploy the Kubernetes manifest generated in the previous step on your local cluster in the signer-ca-system namespace.Ensure that all the services are running.Get the public key of the CA. This is encoded in the secret “signer-ca-*” in the signer-ca-system namespace.The  field contains the base64 encoded public key file. Record this for future use.Load the secret into the istiod namespace.This step is necessary for Istio to verify that the workload certificates have been signed by the correct certificate authority and to add the root-cert to the trust bundle for mTLS to work.Deploy Istio on the cluster using  with the following configuration.Deploy the  sample application in the bookinfo namespace.When the workloads are deployed, above, they send CSR Requests to Istiod which forwards them to the Kubernetes CA for signing. If all goes well, the signed certificates are sent back to the workloads where they are then installed. To verify that they have indeed been signed by the Kubernetes CA, you need to first extract the signed certificates.Dump all pods running in the namespace.Pick any of the running pods for the next step.Get the certificate chain and CA root certificate used by the Istio proxies for mTLS.The  json file contains the CA root certificate for mTLS in the  field. Note that this certificate is base64 encoded.Compare the CA root certificate obtained in the step above with “root-cert.pem” value in external-ca-cert. These two should be the same.(Optional) Follow the rest of the steps in the  to ensure that communication between services is working as expected.Remove the  and  namespaces:Added Security - Unlike  or the default  option, enabling this feature means that the CA private keys need not be present in the Kubernetes cluster.Custom CA Integration - By specifying a Signer name in the Kubernetes CSR Request, this feature allows Istio to integrate with custom Certificate Authorities using the Kubernetes CSR API interface. This does require the custom CA to implement a Kubernetes controller to watch the  and  Resources and act on them.Taking advantage of Kubernetes trustworthy JWTs to issue certificates for workload instances more securely.Learn how to extend the lifetime of Istio self-signed root certificate.Learn how to extend the lifetime of the Istio self-signed root certificate.Shows how to provision and manage DNS certificates in Istio.A mechanism to acquire and share an application certificate and key through mounted files.A vision statement and roadmap for Istio in 2020.Istio 1.8© 2020 Istio Authors, Page last modified: November 2, 2020  This task shows how to provision and manage DNS certificates using , a lightweight component linked with Istiod that signs certificates using the Kubernetes CA APIs without maintaining its own private key. Using this feature has the following advantages:Unlike , this feature doesn’t require maintaining a private signing key, which enhances security.Simplified root certificate distribution to TLS clients. Clients no longer need to wait for Istiod to generate and distribute its CA certificate.Istio provisions the DNS names and secret names for the DNS certificates based on configuration you provide. The DNS certificates provisioned are signed by the Kubernetes CA and stored in the secrets following your configuration. Istio also manages the lifecycle of the DNS certificates, including their rotations and regenerations.The  custom resource used to configure Istio in the  command, above, contains an example DNS certificate configuration. Within, the  field specifies the DNS names in a certificate and the  field specifies the name of the Kubernetes secret used to store the certificate and the key.After configuring Istio to generate DNS certificates and storing them in secrets of your choosing, you can verify that the certificates were provisioned and work properly.To check that Istio generated the  DNS certificate as configured in the example, and that the certificate contains the configured DNS names, you need to get the secret from Kubernetes, parse it, decode it, and view its text output with the following command:The text output should include:Istio can also regenerate DNS certificates that were mistakenly deleted. Next, we show how you can delete a recently configured certificate and verify Istio regenerates it automatically.Delete the secret storing the DNS certificate configured earlier:To check that Istio regenerated the deleted DNS certificate, and that the certificate contains the configured DNS names, you need to get the secret from Kubernetes, parse it, decode it, and view its text output with the following command:The output should include:To remove the  namespace:Taking advantage of Kubernetes trustworthy JWTs to issue certificates for workload instances more securely.Learn how to extend the lifetime of Istio self-signed root certificate.Shows how to use a Custom Certificate Authority (that integrates with the Kubernetes CSR API) to provision Istio workload certificates.Learn how to extend the lifetime of the Istio self-signed root certificate.A mechanism to acquire and share an application certificate and key through mounted files.A vision statement and roadmap for Istio in 2020.Istio 1.8© 2020 Istio Authors, Page last modified: November 10, 2020  This task shows how administrators can configure the Istio certificate authority (CA) with a root certificate, signing certificate and key.By default, Istio’s CA generates a self-signed root certificate and key, and uses them to sign the workload certificates. Istio’s CA can also sign workload certificates using an administrator-specified certificate and key, and with an administrator-specified root certificate.A root CA is used by all workloads within a mesh as the root of trust. Each Istio CA uses an intermediate CA signing key and certificate, signed by the root CA. When multiple Istio CAs exist within a mesh, this establishes a hierarchy of trust among the CAs.This task demonstrates how to generate and plug in the certificates and key for Istio’s CA. These steps can be repeated to provision certificates and keys for any number of Istio CAs.Create a directory for holding certificates and keys:Generate the root certificate and key:This will generate the following files:Generate an intermediate certificate and key:This will generate the following files in a directory named :If you are doing this on an offline machine, copy the generated directory to a machine with access to the clusters.Create a secret  including all the input files , ,  and :Return to the top-level directory of the Istio installation:Deploy Istio using the  profile.Istio’s CA will read certificates and key from the secret-mount files.Deploy the  and  sample services.Deploy a policy for workloads in the  namespace to only accept mutual TLS traffic.In this section, we verify that workload certificates are signed by the certificates that we plugged into the CA. This requires you have  installed on your machine.Sleep 20 seconds for the mTLS policy to take effect before retrieving the certificate chain of . As the CA certificate used in this example is self-signed, the  error returned by the openssl command is expected.Parse the certificates on the certificate chain.Verify the root certificate is the same as the one specified by the administrator:Verify the CA certificate is the same as the one specified by the administrator:Verify the certificate chain from the root certificate to the workload certificate:Remove the certificates, keys, and intermediate files from your local disk:Remove the secret , and the  and  namespaces:To remove the Istio components: follow the  to remove.Provision and manage DNS certificates in Istio.A vision statement and roadmap for Istio in 2020.A more secure way to manage secrets.Introduction, motivation and design principles for the Istio v1beta1 Authorization Policy.A more secure way to manage Istio webhooks.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Istio 1.8© 2020 Istio Authors, Page last modified: November 2, 2020  This task shows you how to configure circuit breaking for connections, requests, and outlier detection.Circuit breaking is an important pattern for creating resilient microservice applications. Circuit breaking allows you to write applications that limit the impact of failures, latency spikes, and other undesirable effects of network peculiarities.In this task, you will configure circuit breaking rules and then test the configuration by intentionally “tripping” the circuit breaker.Start the  sample.If you have enabled , deploy the  service:Otherwise, you have to manually inject the sidecar before deploying the  application:The  application serves as the backend service for this task.Create a  to apply circuit breaking settings when calling the  service:Verify the destination rule was created correctly:Create a client to send traffic to the  service. The client is a simple load-testing client called . Fortio lets you control the number of connections, concurrency, and delays for outgoing HTTP calls. You will use this client to “trip” the circuit breaker policies you set in the . Inject the client with the Istio sidecar proxy so network interactions are governed by Istio.If you have enabled , deploy the  service:Otherwise, you have to manually inject the sidecar before deploying the  application:Log in to the client pod and use the fortio tool to call . Pass in  to indicate that you just want to make one call:You can see the request succeeded! Now, it’s time to break something.In the  settings, you specified  and . These rules indicate that if you exceed more than one connection and request concurrently, you should see some failures when the opens the circuit for further requests and connections.Call the service with two concurrent connections () and send 20 requests ():It’s interesting to see that almost all requests made it through! The does allow for some leeway.Bring the number of concurrent connections up to 3:Now you start to see the expected circuit breaking behavior. Only 36.7% of the requests succeeded and the rest were trapped by circuit breaking:Query the  stats to see more:You can see  for the  value which means calls so far have been flagged for circuit breaking.Remove the rules:Shutdown the  service and client:Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Automating Istio configuration for Istio deployments (clusters) that work as a single mesh.Configure Istio ingress gateway to act as a proxy for external services.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: August 4, 2020  Because all outbound traffic from an Istio-enabled pod is redirected to its sidecar proxy by default, accessibility of URLs outside of the cluster depends on the configuration of the proxy. By default, Istio configures the Envoy proxy to passthrough requests for unknown services. Although this provides a convenient way to get started with Istio, configuring stricter control is usually preferable.This task shows you how to access external services in three different ways:Setup Istio by following the instructions in the . Use the   or otherwise .Deploy the  sample app to use as a test source for sending requests. If you have  enabled, run the following command to deploy the sample app:Otherwise, manually inject the sidecar before deploying the  application with the following command:Set the  environment variable to the name of your source pod:Istio has an , , that configures the sidecar handling of external services, that is, those services that are not defined in Istio’s internal service registry. If this option is set to , the Istio proxy lets calls to unknown services pass through. If the option is set to , then the Istio proxy blocks any host without an HTTP service or service entry defined within the mesh. is the default value, allowing you to start evaluating Istio quickly, without controlling access to external services. You can then decide to  later.To see this approach in action you need to ensure that your Istio installation is configured with the  option set to . Unless you explicitly set it to  mode when you installed Istio, it is probably enabled by default.Run the following command to verify that  option is set to or is omitted:You should either see  or no output (default ).If you have explicitly configured  mode, you can change it by rerunning your original  command with the changed setting, for example:Make a couple of requests to external HTTPS services from the  to confirm successful  responses:Congratulations! You successfully sent egress traffic from your mesh.This simple approach to access external services, has the drawback that you lose Istio monitoring and control for traffic to external services. The next section shows you how to monitor and control your mesh’s access to external services.Using Istio  configurations, you can access any publicly accessible service from within your Istio cluster. This section shows you how to configure access to an external HTTP service, , as well as an external HTTPS service, without losing Istio’s traffic monitoring and control features.To demonstrate the controlled way of enabling access to external services, you need to change the option from the  mode to the  mode.Change the  option to .If you used an  CR to install Istio, add the following field to your configuration:Otherwise, add the equivalent setting to your original  command, for example:Make a couple of requests to external HTTPS services from  to verify that they are now blocked:Create a  to allow access to an external HTTP service. resolution is used in the service entry below as a security measure. Setting the resolution to opens a possibility for attack. A malicious client could pretend that it’s accessing  by setting it in the  header, while really connecting to a different IP (that is not associated with ). The Istio sidecar proxy will trust the HOST header, and incorrectly allow the traffic, even though it is being delivered to the IP address of a different host. That host can be a malicious site, or a legitimate site, prohibited by the mesh security policies.With  resolution, the sidecar proxy will ignore the original destination IP address and direct the traffic to , performing a DNS query to get an IP address of .Make a request to the external HTTP service from :Note the headers added by the Istio sidecar proxy: .Check the log of the sidecar proxy of :Note the entry related to your HTTP request to .Create a  to allow access to an external HTTPS service.Make a request to the external HTTPS service from :Check the log of the sidecar proxy of :Note the entry related to your HTTPS request to .Similar to inter-cluster requests, Istio  can also be set for external services that are accessed using  configurations. In this example, you set a timeout rule on calls to the  service.From inside the pod being used as the test source, make a  request to the  endpoint of the httpbin.org external service:The request should return 200 (OK) in approximately 5 seconds.Use  to set a 3s timeout on calls to the  external service:Wait a few seconds, then make the  request again:This time a 504 (Gateway Timeout) appears after 3 seconds. Although httpbin.org was waiting 5 seconds, Istio cut off the request at 3 seconds.If you want to completely bypass Istio for a specific IP range, you can configure the Envoy sidecars to prevent them from  external requests. To set up the bypass, change either the or the   and update the  configuration map using the  command. This can also be configured on a pod by setting corresponding  such as . After updating the  configuration, it affects all future application pod deployments.A simple way to exclude all external IPs from being redirected to the sidecar proxy is to set the  configuration option to the IP range or ranges used for internal cluster services. These IP range values depend on the platform where your cluster runs.Set the value of  according to your cluster provider.Get your  from IBM Cloud Private configuration file under :The following is a sample output:Use Use The ranges are not fixed, so you will need to run the  command to determine the ranges to use. For example:Use Use The default value is , but it’s not fixed. Use the following command to determine your actual value:Use Update your  configuration map using the IP ranges specific to your platform. For example, if the range is 10.0.0.1/24, use the following command:Use the same command that you used to  and add .Because the bypass configuration only affects new deployments, you need to terminate and then redeploy the application as described in the  section.After updating the  configmap and redeploying the  application, the Istio sidecar will only intercept and manage internal requests within the cluster. Any external request bypasses the sidecar and goes straight to its intended destination. For example:Unlike accessing external services through HTTP or HTTPS, you don’t see any headers related to the Istio sidecar and the requests sent to external services do not appear in the log of the sidecar. Bypassing the Istio sidecars means you can no longer monitor the access to external services.Update the configuration to stop bypassing sidecar proxies for a range of IPs:In this task you looked at three ways to call external services from an Istio mesh:Configuring Envoy to allow access to any external service.Use a service entry to register an accessible external service inside the mesh. This is the recommended approach.Configuring the Istio sidecar to exclude external IPs from its remapped IP table.The first approach directs traffic through the Istio sidecar proxy, including calls to services that are unknown inside the mesh. When using this approach, you can’t monitor access to external services or take advantage of Istio’s traffic control features for them. To easily switch to the second approach for specific services, simply create service entries for those external services. This process allows you to initially access any external service and then later decide whether or not to control access, enable traffic monitoring, and use traffic control features as needed.The second approach lets you use all of the same Istio service mesh features for calls to services inside or outside of the cluster. In this task, you learned how to monitor access to external services and set a timeout rule for calls to an external service.The third approach bypasses the Istio sidecar proxy, giving your services direct access to any external server. However, configuring the proxy this way does require cluster-provider specific knowledge and configuration. Similar to the first approach, you also lose monitoring of access to external services and you can’t apply Istio features on traffic to external services.To implement egress traffic control in a more secure way, you must  and review the security concerns described in the  section.Shutdown the  service:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: September 9, 2020  The  task shows how to configure Istio to allow access to external HTTP and HTTPS services from applications inside the mesh. There, the external services are called directly from the client sidecar. This example also shows how to configure Istio to call external services, although this time indirectly via a dedicated  service.Istio uses to configure load balancers executing at the edge of a service mesh. An ingress gateway allows you to define entry points into the mesh that all incoming traffic flows through. Egress gateway is a symmetrical concept; it defines exit points from the mesh. Egress gateways allow you to apply Istio features, for example, monitoring and route rules, to traffic exiting the mesh.Consider an organization that has a strict security requirement that all traffic leaving the service mesh must flow through a set of dedicated nodes. These nodes will run on dedicated machines, separated from the rest of the nodes running applications in the cluster. These special nodes will serve for policy enforcement on the egress traffic and will be monitored more thoroughly than other nodes.Another use case is a cluster where the application nodes don’t have public IPs, so the in-mesh services that run on them cannot access the Internet. Defining an egress gateway, directing all the egress traffic through it, and allocating public IPs to the egress gateway nodes allows the application nodes to access external services in a controlled way.Setup Istio by following the instructions in the .Deploy the  sample app to use as a test source for sending requests. If you have  enabled, run the following command to deploy the sample app:Otherwise, manually inject the sidecar before deploying the  application with the following command:Set the  environment variable to the name of your source pod:Check if the Istio egress gateway is deployed:If no pods are returned, deploy the Istio egress gateway by performing the following step.If you used an  CR to install Istio, add the following fields to your configuration:Otherwise, add the equivalent settings to your original  command, for example:First create a  to allow direct traffic to an external service.Define a  for . resolution must be used in the service entry below. If the resolution is , the gateway will direct the traffic to itself in an infinite loop. This is because the gateway receives a request with the original destination IP address which is equal to the service IP of the gateway (since the request is directed by sidecar proxies to the gateway).With  resolution, the gateway performs a DNS query to get an IP address of the external service and directs the traffic to that IP address.Verify that your  was applied correctly by sending an HTTP request to .The output should be the same as in the example, without TLS origination.Create an egress  for , port 80, and a destination rule for traffic directed to the egress gateway.Define a  to direct traffic from the sidecars to the egress gateway and from the egress gateway to the external service:Resend the HTTP request to .The output should be the same as in the step 2.Check the log of the  pod for a line corresponding to our request. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Note that you only redirected the traffic from port 80 to the egress gateway. The HTTPS traffic to port 443 went directly to .Remove the previous definitions before proceeding to the next step:In this section you direct HTTPS traffic (TLS originated by the application) through an egress gateway. You need to specify port 443 with protocol  in a corresponding , an egress  and a .Define a  for :Verify that your  was applied correctly by sending an HTTPS request to .Create an egress  for , a destination rule and a virtual service to direct the traffic through the egress gateway and from the egress gateway to the external service.Send an HTTPS request to . The output should be the same as before.Check the log of the egress gateway’s proxy. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Note that defining an egress  in Istio does not in itself provides any special treatment for the nodes on which the egress gateway service runs. It is up to the cluster administrator or the cloud provider to deploy the egress gateways on dedicated nodes and to introduce additional security measures to make these nodes more secure than the rest of the mesh.Istio  that all egress traffic actually flows through the egress gateways. Istio only enables such flow through its sidecar proxies. If attackers bypass the sidecar proxy, they could directly access external services without traversing the egress gateway. Thus, the attackers escape Istio’s control and monitoring. The cluster administrator or the cloud provider must ensure that no traffic leaves the mesh bypassing the egress gateway. Mechanisms external to Istio must enforce this requirement. For example, the cluster administrator can configure a firewall to deny all traffic not coming from the egress gateway. The  can also forbid all the egress traffic not originating from the egress gateway (see for an example). Additionally, the cluster administrator or the cloud provider can configure the network to ensure application nodes can only access the Internet via a gateway. To do this, the cluster administrator or the cloud provider can prevent the allocation of public IPs to pods other than gateways and can configure NAT devices to drop packets not originating at the egress gateways.This section shows you how to create a to prevent bypassing of the egress gateway. To test the network policy, you create a namespace, , deploy the  sample to it, and then attempt to send requests to a gateway-secured external service.Follow the steps in the section.Create the  namespace:Deploy the  sample to the  namespace.Check that the deployed pod has a single container with no Istio sidecar attached:Send an HTTPS request to  from the  pod in the  namespace. The request will succeed since you did not define any restrictive policies yet.Label the namespaces where the Istio components (the control plane and the gateways) run. If you deployed the Istio components to , the command is:Label the  namespace.Define a  to limit the egress traffic from the  namespace to traffic destined to , and to the  DNS service (port 53):Resend the previous HTTPS request to . Now it should fail since the traffic is blocked by the network policy. Note that the  pod cannot bypass . The only way it can access  is by using an Istio sidecar proxy and by directing the traffic to . This setting demonstrates that even if some malicious pod manages to bypass its sidecar proxy, it will not be able to access external sites and will be blocked by the network policy.Now inject an Istio sidecar proxy into the  pod in the  namespace by first enabling automatic sidecar proxy injection in the  namespace:Then redeploy the  deployment:Check that the deployed pod has two containers, including the Istio sidecar proxy ():Create the same destination rule as for the  pod in the  namespace to direct the traffic through the egress gateway:Send an HTTPS request to . Now it should succeed since the traffic flows to  in the  namespace, which is allowed by the Network Policy you defined.  forwards the traffic to .Check the log of the egress gateway’s proxy. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Delete the resources created in this section:Follow the steps in the  section.If  is enabled, verify the correct certificate of the egress gateway:For HTTPS traffic (TLS originated by the application), test the traffic flow by using the  command. has an explicit option for setting the SNI, namely .If you get the certificate as in the output above, your traffic is routed correctly. Check the statistics of the egress gateway’s proxy and see a counter that corresponds to your requests (sent by  and ) to .Shutdown the  service:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: October 23, 2020  The example shows how to configure Istio to perform for traffic to an external service. The example shows how to configure Istio to direct egress traffic through a dedicated  service. This example combines the previous two by describing how to configure an egress gateway to perform TLS origination for traffic to external services.Setup Istio by following the instructions in the .Start the  sample which will be used as a test source for external calls.If you have enabled , dootherwise, you have to manually inject the sidecar before deploying the  application:Note that any pod that you can  and  from would do.Create a shell variable to hold the name of the source pod for sending requests to external services. If you used the  sample, run:For macOS users, verify that you are using  version 1.1 or later:If the previous command outputs a version  or later, as shown, your  command should work correctly with the instructions in this task. Otherwise, upgrade your  or try a different implementation of , for example on a Linux machine..This section describes how to perform the same TLS origination as in the example, only this time using an egress gateway. Note that in this case the TLS origination will be done by the egress gateway, as opposed to by the sidecar in the previous example.Define a  for :Verify that your  was applied correctly by sending a request to .Your  was configured correctly if you see  in the output.Create an egress  for , port 80, and a destination rule for sidecar requests that will be directed to the egress gateway.Define a  to direct the traffic through the egress gateway, and a to perform TLS origination for requests to :Send an HTTP request to .The output should be the same as in the example, with TLS origination: without the  message.Check the log of the  pod and you should see a line corresponding to our request. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Remove the Istio configuration items you created:Similar to the previous section, this section describes how to configure an egress gateway to perform TLS origination for an external service, only this time using a service that requires mutual TLS.This example is considerably more involved because you need to first:Only then can you configure the external traffic to go through the egress gateway which will perform TLS origination.For this task you can use your favorite tool to generate certificates and keys. The commands below use Create a root certificate and private key to sign the certificate for your services:Create a certificate and a private key for :Generate client certificate and private key:To simulate an actual external service that supports the mutual TLS protocol, deploy an  server in your Kubernetes cluster, but running outside of the Istio service mesh, i.e., in a namespace without Istio sidecar proxy injection enabled.Create a namespace to represent services outside the Istio mesh, namely . Note that the sidecar proxy will not be automatically injected into the pods in this namespace since the automatic sidecar injection was not on it.Create Kubernetes  to hold the server’s and CA certificates.Create a configuration file for the NGINX server:Create a Kubernetes to hold the configuration of the NGINX server:Deploy the NGINX server:Create Kubernetes  to hold the client’s and CA certificates.To include a volume mounted from the new created secret, update the  deployment. To patch the  deployment, create the following  file:Apply  deployment patch with the following command:Verify that the key and the certificate are successfully loaded in the  pod: and  should exist in , while  in .Create an egress  for , port 443, and destination rules and virtual services to direct the traffic through the egress gateway and from the egress gateway to the external service.Define a  to direct the traffic through the egress gateway:Add a  to perform mutual TLS originationSend an HTTP request to :Check the log of the  pod for a line corresponding to our request. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Remove created Kubernetes resources:Delete the certificates and private keys:Delete the generated configuration files used in this example:Delete the  service and deployment:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: September 21, 2020  The example shows how to configure Istio to perform for traffic to an external service. The example shows how to configure Istio to direct egress traffic through a dedicated  service. This example combines the previous two by describing how to configure an egress gateway to perform TLS origination for traffic to external services.The TLS required private key, server certificate, and root certificate, are configured using the .Setup Istio by following the instructions in the .Start the  sample which will be used as a test source for external calls.If you have enabled , dootherwise, you have to manually inject the sidecar before deploying the  application:Note that any pod that you can  and  from would do.For macOS users, verify that you are using  version 1.1 or later:If the previous command outputs a version  or later, as shown, your  command should work correctly with the instructions in this task. Otherwise, upgrade your  or try a different implementation of , for example on a Linux machine...This section describes how to perform the same TLS origination as in the example, only this time using an egress gateway. Note that in this case the TLS origination will be done by the egress gateway, as opposed to by the sidecar in the previous example. The egress gateway will use SDS instead of the file-mount to provision client certificates.For this task you can use your favorite tool to generate certificates and keys. The commands below use .Create a root certificate and private key to sign the certificate for your services:Create a certificate and a private key for :To simulate an actual external service that supports the simple TLS protocol, deploy an  server in your Kubernetes cluster, but running outside of the Istio service mesh, i.e., in a namespace without Istio sidecar proxy injection enabled.Create a namespace to represent services outside the Istio mesh, namely . Note that the sidecar proxy will not be automatically injected into the pods in this namespace since the automatic sidecar injection was not on it.Create Kubernetes  to hold the server’s and CA certificates.Create a configuration file for the NGINX server:Create a Kubernetes to hold the configuration of the NGINX server:Deploy the NGINX server:Create a Kubernetes Secret to hold the CA certificate used by egress gateway to originate TLS connections:Note that the secret name for an Istio CA-only certificate must end with  and the secret  be created in the same namespace as Istio is deployed in,  in this case.Create an egress  for , port 443, and destination rules and virtual services to direct the traffic through the egress gateway and from the egress gateway to the external service.Define a  to direct the traffic through the egress gateway:Add a  to perform simple TLS originationSend an HTTP request to :Check the log of the  pod for a line corresponding to our request. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Remove the Istio configuration items you created:Delete the certificates and private keys:Delete the generated configuration files used in this example:Similar to the previous section, this section describes how to configure an egress gateway to perform TLS origination for an external service, only this time using a service that requires mutual TLS.Egress Gateway will use SDS instead of the file-mount to provision client certificates.For this task you can use your favorite tool to generate certificates and keys. The commands below use .Create a root certificate and private key to sign the certificate for your services:Create a certificate and a private key for :Generate client certificate and private key:To simulate an actual external service that supports the mutual TLS protocol, deploy an  server in your Kubernetes cluster, but running outside of the Istio service mesh, i.e., in a namespace without Istio sidecar proxy injection enabled.Create a namespace to represent services outside the Istio mesh, namely . Note that the sidecar proxy will not be automatically injected into the pods in this namespace since the automatic sidecar injection was not on it.Create Kubernetes  to hold the server’s certificates.Create a configuration file for the NGINX server:Create a Kubernetes to hold the configuration of the NGINX server:Deploy the NGINX server:Create Kubernetes  to hold the client’s certificates:The secret  be created in the same namespace as Istio is deployed in,  in this case.To support integration with various tools, Istio supports a few different Secret formats.In this example. a single generic Secret with keys , , and  is used.Create an egress  for , port 443, and destination rules and virtual services to direct the traffic through the egress gateway and from the egress gateway to the external service.Define a  to direct the traffic through the egress gateway:Add a  to perform mutual TLS originationSend an HTTP request to :Check the log of the  pod for a line corresponding to our request. If Istio is deployed in the  namespace, the command to print the log is:You should see a line similar to the following:Remove created Kubernetes resources:Delete the certificates and private keys:Delete the generated configuration files used in this example:Delete the  service and deployment:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: August 11, 2020  Kubernetes services and Kubernetes services with  let you create a local DNS  to an external service. This DNS alias has the same form as the DNS entries for local services, namely . DNS aliases provide  for your workloads: the workloads can call local and external services in the same way. If at some point in time you decide to deploy the external service inside your cluster, you can just update its Kubernetes service to reference the local version. The workloads will continue to operate without any change.This task shows that these Kubernetes mechanisms for accessing external services continue to work with Istio. The only configuration step you must perform is to use a TLS mode other than Istio’s . The external services are not part of an Istio service mesh so they cannot perform the mutual TLS of Istio. You must set the TLS mode according to the TLS requirements of the external service and according to the way your workload accesses the external service. If your workload issues plain HTTP requests and the external service requires TLS, you may want to perform TLS origination by Istio. If your workload already uses TLS, the traffic is already encrypted and you can just disable Istio’s mutual TLS.While the examples in this task use HTTP protocols, Kubernetes Services for egress traffic work with other protocols as well.Setup Istio by following the instructions in the .Deploy the  sample app to use as a test source for sending requests. If you have  enabled, run the following command to deploy the sample app:Otherwise, manually inject the sidecar before deploying the  application with the following command:Set the  environment variable to the name of your source pod:Create a namespace for a source pod without Istio control:Start the  sample in the  namespace.To send requests, create the  environment variable to store the name of the source pod:Verify that the Istio sidecar was not injected, that is the pod has one container:Create a Kubernetes service for  in the default namespace:Observe your service. Note that it does not have a cluster IP.Access  via the Kubernetes service’s hostname from the source pod without Istio sidecar. Note that the  command below uses the : .In this example, unencrypted HTTP requests are sent to . For the sake of the example only, you disable the TLS mode and allow the unencrypted traffic to the external service. In the real life scenarios, we recommend to perform  by Istio.Access  via the Kubernetes service’s hostname from the source pod with Istio sidecar. Notice the headers added by Istio sidecar, for example . Also note that the  header equals to your service’s hostname.Create a Kubernetes service without selector for Wikipedia:Create endpoints for your service. Pick a couple of IPs from the .Observe your service. Note that it has a cluster IP which you can use to access .Send HTTPS requests to  by your Kubernetes service’s cluster IP from the source pod without Istio sidecar. Use the  option of  to access  by the cluster IP:In this case, the workload send HTTPS requests (open TLS connection) to the . The traffic is already encrypted by the workload so you can safely disable Istio’s mutual TLS:Access  by your Kubernetes service’s cluster IP from the source pod with Istio sidecar:Check that the access is indeed performed by the cluster IP. Notice the sentence in the output of , it mentions the IP that was printed in the output of your service as the cluster IP.Shutdown the  service:Shutdown the  service in the  namespace:Delete  namespace:Unset the environment variables:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: August 11, 2020  The  task demonstrates how external, i.e., outside of the service mesh, HTTP and HTTPS services can be accessed from applications inside the mesh. As described in that task, a  is used to configure Istio to access external services in a controlled way. This example shows how to configure Istio to perform for traffic to an external service. Istio will open HTTPS connections to the external service while the original traffic is HTTP.Consider a legacy application that performs HTTP calls to external sites. Suppose the organization that operates the application receives a new requirement which states that all the external traffic must be encrypted. With Istio, this requirement can be achieved just by configuration, without changing any code in the application. The application can send unencrypted HTTP requests and Istio will then encrypt them for the application.Another benefit of sending unencrypted HTTP requests from the source, and letting Istio perform the TLS upgrade, is that Istio can produce better telemetry and provide more routing control for requests that are not encrypted.Setup Istio by following the instructions in the .Start the  sample which will be used as a test source for external calls.If you have enabled , deploy the  application:Otherwise, you have to manually inject the sidecar before deploying the  application:Note that any pod that you can  and  from will do for the procedures below.Create a shell variable to hold the name of the source pod for sending requests to external services. If you used the  sample, run:First start by configuring access to an external service, , using the same technique shown in the  task. This time, however, use a single  to enable both HTTP and HTTPS access to the service.Create a  to enable access to :Make a request to the external HTTP service:The output should be similar to the above (some details replaced by ellipsis).Notice the  flag of  which instructs  to follow redirects. In this case, the server returned a redirect response () for the HTTP request to . The redirect response instructs the client to send an additional request, this time using HTTPS, to . For the second request, the server returned the requested content and a  status code.Although the  command handled the redirection transparently, there are two issues here. The first issue is the redundant request, which doubles the latency of fetching the content of . The second issue is that the path of the URL,  in this case, is sent in clear text. If there is an attacker who sniffs the communication between your application and , the attacker would know which specific topics of  the application fetched. For privacy reasons, you might want to prevent such disclosure.Both of these issues can be resolved by configuring Istio to perform TLS origination.Redefine your  from the previous section to redirect HTTP requests to port 443 and add a  to perform TLS origination:The above  will perform TLS origination for HTTP requests on port 80 and the will then redirect the requests on port 80 to target port 443.Send an HTTP request to , as in the previous section:This time you receive  as the first and the only response. Istio performed TLS origination for  so the original HTTP request was forwarded to  as HTTPS. The server returned the content directly, without the need for redirection. You eliminated the double round trip between the client and the server, and the request left the mesh encrypted, without disclosing the fact that your application fetched the  section of .Note that you used the same command as in the previous section. For applications that access external services programmatically, the code does not need to be changed. You get the benefits of TLS origination by configuring Istio, without changing a line of code.Note that the applications that used HTTPS to access the external service continue to work as before:Because the traffic between the application pod and the sidecar proxy on the local host is still unencrypted, an attacker that is able to penetrate the node of your application would still be able to see the unencrypted communication on the local network of the node. In some environments a strict security requirement might state that all the traffic must be encrypted, even on the local network of the nodes. With such a strict requirement, applications should use HTTPS (TLS) only. The TLS origination described in this example would not be sufficient.Also note that even with HTTPS originated by the application, an attacker could know that requests to are being sent by inspecting . The  field is sent unencrypted during the TLS handshake. Using HTTPS prevents the attackers from knowing specific topics and articles but does not prevent an attackers from learning that  is accessed.Remove the Istio configuration items you created:Shutdown the  service:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: October 27, 2020  The  example shows how to direct traffic to external services from your mesh via an Istio edge component called . However, some cases require an external, legacy (non-Istio) HTTPS proxy to access external services. For example, your company may already have such a proxy in place and all the applications within the organization may be required to direct their traffic through it.This example shows how to enable access to an external HTTPS proxy. Since applications use the HTTP  method to establish connections with HTTPS proxies, configuring traffic to an external HTTPS proxy is different from configuring traffic to external HTTP and HTTPS services.Setup Istio by following the instructions in the .Deploy the  sample app to use as a test source for sending requests. If you have  enabled, run the following command to deploy the sample app:Otherwise, manually inject the sidecar before deploying the  application with the following command:Set the  environment variable to the name of your source pod:To simulate a legacy proxy and only for this example, you deploy an HTTPS proxy inside your cluster. Also, to simulate a more realistic proxy that is running outside of your cluster, you will address the proxy’s pod by its IP address and not by the domain name of a Kubernetes service. This example uses  but you can use any HTTPS proxy that supports HTTP CONNECT.Create a namespace for the HTTPS proxy, without labeling it for sidecar injection. Without the label, sidecar injection is disabled in the new namespace so Istio will not control the traffic there. You need this behavior to simulate the proxy being outside of the cluster.Create a configuration file for the Squid proxy.Create a Kubernetes to hold the configuration of the proxy:Deploy a container with Squid:Deploy the  sample in the  namespace to test traffic to the proxy without Istio traffic control.Obtain the IP address of the proxy pod and define the  environment variable to store it:Define the  environment variable to store the port of your proxy. In this case, Squid uses port 3128.Send a request from the  pod in the  namespace to an external service via the proxy:Check the access log of the proxy for your request:So far, you completed the following tasks without Istio:Next, you must configure the traffic from the Istio-enabled pods to use the HTTPS proxy.Define a TCP (not HTTP!) Service Entry for the HTTPS proxy. Although applications use the HTTP CONNECT method to establish connections with HTTPS proxies, you must configure the proxy for TCP traffic, instead of HTTP. Once the connection is established, the proxy simply acts as a TCP tunnel.Send a request from the  pod in the  namespace. Because the  pod has a sidecar, Istio controls its traffic.Check the Istio sidecar proxy’s logs for your request:Check the access log of the proxy for your request:In this example, you took the following steps:Note that you must not create service entries for the external services you access through the external proxy, like . This is because from Istio’s point of view the requests are sent to the external proxy only; Istio is not aware of the fact that the external proxy forwards the requests further.Shutdown the  service:Shutdown the  service in the  namespace:Shutdown the Squid proxy, remove the  and the configuration file:Delete the  namespace:Delete the Service Entry:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: August 11, 2020  The  task and the  example describe how to configure egress traffic for specific hostnames, like . This example shows how to enable egress traffic for a set of hosts in a common domain, for example , instead of configuring each and every host separately.Suppose you want to enable egress traffic in Istio for the  sites in all languages. Each version of  in a particular language has its own hostname, e.g.,  and in the English and the German languages, respectively. You want to enable egress traffic by common configuration items for all the Wikipedia sites, without the need to specify every language’s site separately.Install Istio using the and with the blocking-by-default outbound traffic policy:Deploy the  sample app to use as a test source for sending requests. If you have  enabled, run the following command to deploy the sample app:Otherwise, manually inject the sidecar before deploying the  application with the following command:Set the  environment variable to the name of your source pod:The first, and simplest, way to access a set of hosts within a common domain is by configuring a simple  with a wildcard host and calling the services directly from the sidecar. When calling services directly (i.e., not via an egress gateway), the configuration for a wildcard host is no different than that of any other (e.g., fully qualified) host, only much more convenient when there are many hosts within the common domain.Define a  for :Send HTTPS requests to and :The configuration for accessing a wildcard host via an egress gateway depends on whether or not the set of wildcard domains are served by a single common host. This is the case for . All of the language-specific sites are served by every one of the  servers. You can route the traffic to an IP of any  site, including , and it will any specific site.In the general case, where all the domain names of a wildcard are not served by a single hosting server, a more complex configuration is required.When all wildcard hosts are served by a single server, the configuration for egress gateway-based access to a wildcard host is very similar to that of any host, with one exception: the configured route destination will not be the same as the configured host, i.e., the wildcard. It will instead be configured with the host of the single server for the set of domains.Create an egress  for , a destination rule and a virtual service to direct the traffic through the egress gateway and from the egress gateway to the external service.Create a  for the destination server, .Send HTTPS requests to and :Check the statistics of the egress gateway’s proxy for the counter that corresponds to your requests to . If Istio is deployed in the  namespace, the command to print the counter is:The configuration in the previous section worked because all the  sites can be served by any one of the  servers. However, this is not always the case. For example, you may want to configure egress control for access to more general wildcard domains like  or .Configuring traffic to arbitrary wildcard domains introduces a challenge for Istio gateways. In the previous section you directed the traffic to , which was made known to your gateway during configuration. The gateway, however, would not know the IP address of any arbitrary host it receives in a request. This is due to a limitation of , the proxy used by the default Istio egress gateway. Envoy routes traffic either to predefined hosts, predefined IP addresses, or to the original destination IP address of the request. In the gateway case, the original destination IP of the request is lost since the request is first routed to the egress gateway and its destination IP address is the IP address of the gateway.Consequently, the Istio gateway based on Envoy cannot route traffic to an arbitrary host that is not preconfigured, and therefore is unable to perform traffic control for arbitrary wildcard domains. To enable such traffic control for HTTPS, and for any TLS, you need to deploy an SNI forward proxy in addition to Envoy. Envoy will route the requests destined for a wildcard domain to the SNI forward proxy, which, in turn, will forward the requests to the destination specified by the SNI value.The egress gateway with SNI proxy and the related parts of the Istio architecture are shown in the following diagram:The following sections show you how to redeploy the egress gateway with an SNI proxy and then configure Istio to route HTTPS traffic through the gateway to arbitrary wildcard domains.In this section you deploy an egress gateway with an SNI proxy in addition to the standard Istio Envoy proxy. This example uses  for the SNI proxy, although any SNI proxy that is capable of routing traffic according to arbitrary, not-preconfigured, SNI values would do. The SNI proxy will listen on port , although you can use any port other than the ports specified for the egress  and for the  bound to it. The SNI proxy will forward the traffic to port .Create a configuration file for the Nginx SNI proxy. You may want to edit the file to specify additional Nginx settings, if required. Note that the  directive of the  specifies port , its directive uses  with port  and  is  to enable  reading.Create a Kubernetes to hold the configuration of the Nginx SNI proxy:Create an  CR to add a new egress gateway with SNI proxy:Deploy the new gateway:Verify that the new egress gateway is running. Note that the pod has two containers (one is the Envoy proxy and the second one is the SNI proxy).Create a service entry with a static address equal to 127.0.0.1 (), and disable mutual TLS for traffic directed to the new service entry:Define a  for :Create an egress  for , port 443, protocol TLS, and a virtual service to direct the traffic destined for  through the gateway.Add an  to the gateway, to prevent it from being deceived.Send HTTPS requests to and :Check the log of the egress gateway’s Envoy proxy. If Istio is deployed in the  namespace, the command to print the log is:You should see lines similar to the following:Check the logs of the SNI proxy. If Istio is deployed in the  namespace, the command to print the log is:Delete the configuration items for :Delete the configuration items for the  deployment:Remove the configuration files you created:Shutdown the  service:Uninstall Istio from your cluster:Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Attacks involving egress traffic and requirements for egress traffic control.Verifies the performance impact of adding an egress gateway.Describes a simple scenario based on Istio's Bookinfo example.Describes how to configure Istio for monitoring and access policies of HTTP egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: October 23, 2020  This task shows you how to inject faults to test the resiliency of your application.Set up Istio by following the instructions in the .Deploy the  sample application including the .Review the fault injection discussion in the concepts doc.Apply application version routing by either performing the task or by running the following commands:With the above configuration, this is how requests flow:To test the Bookinfo application microservices for resiliency, inject a 7s delay between the  and  microservices for user . This test will uncover a bug that was intentionally introduced into the Bookinfo app.Note that the  service has a 10s hard-coded connection timeout for calls to the  service. Even with the 7s delay that you introduced, you still expect the end-to-end flow to continue without any errors.Create a fault injection rule to delay traffic coming from the test user .Confirm the rule was created:Allow several seconds for the new rule to propagate to all pods.Open the  web application in your browser.On the  web page, log in as user .You expect the Bookinfo home page to load without errors in approximately 7 seconds. However, there is a problem: the Reviews section displays an error message:View the web page response times:You’ve found a bug. There are hard-coded timeouts in the microservices that have caused the  service to fail.As expected, the 7s delay you introduced doesn’t affect the  service because the timeout between the  and  service is hard-coded at 10s. However, there is also a hard-coded timeout between the  and the  service, coded as 3s + 1 retry for 6s total. As a result, the  call to  times out prematurely and throws an error after 6s.Bugs like this can occur in typical enterprise applications where different teams develop different microservices independently. Istio’s fault injection rules help you identify such anomalies without impacting end users.You would normally fix the problem by:However, you already have a fix running in v3 of the  service. The  service reduces the  to  timeout from 10s to 2.5s so that it is compatible with (less than) the timeout of the downstream  requests.If you migrate all traffic to  as described in the task, you can then try to change the delay rule to any amount less than 2.5s, for example 2s, and confirm that the end-to-end flow continues without any errors.Another way to test microservice resiliency is to introduce an HTTP abort fault. In this task, you will introduce an HTTP abort to the  microservices for the test user .In this case, you expect the page to load immediately and display the  message.Create a fault injection rule to send an HTTP abort for user :Confirm the rule was created:Open the  web application in your browser.On the , log in as user .If the rule propagated successfully to all pods, the page loads immediately and the  message appears.If you log out from user  or open the Bookinfo application in an anonymous window (or in another browser), you will see that  still calls (which does not call  at all) for everybody but . Therefore you will not see any error message.Remove the application routing rules:If you are not planning to explore any follow-on tasks, refer to the instructions to shutdown the application.Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Automating Istio configuration for Istio deployments (clusters) that work as a single mesh.Configure Istio ingress gateway to act as a proxy for external services.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  Along with support for Kubernetes , Istio offers another configuration model, . A  provides more extensive customization and flexibility than , and allows Istio features such as monitoring and route rules to be applied to traffic entering the cluster.This task describes how to configure Istio to expose a service outside of the service mesh using an Istio .Setup Istio by following the instructions in the .Make sure your current directory is the  directory.Start the  sample.If you have enabled , deploy the  service:Otherwise, you have to manually inject the sidecar before deploying the  application:Execute the following command to determine if your Kubernetes cluster is running in an environment that supports external load balancers:If the  value is set, your environment has an external load balancer that you can use for the ingress gateway. If the  value is  (or perpetually ), your environment does not provide an external load balancer for the ingress gateway. In this case, you can access the gateway using the service’s .Choose the instructions corresponding to your environment:Follow these instructions if you have determined that your environment has an external load balancer.Set the ingress IP and ports:In certain environments, the load balancer may be exposed using a host name, instead of an IP address. In this case, the ingress gateway’s  value will not be an IP address, but rather a host name, and the above command will have failed to set the  environment variable. Use the following command to correct the  value:Follow these instructions if you have determined that your environment does not have an external load balancer, so you need to use a node port instead.Set the ingress ports:Setting the ingress IP depends on the cluster provider:You need to create firewall rules to allow the TCP traffic to the  service’s ports. Run the following commands to allow the traffic for the HTTP port, the secure port (HTTPS) or both:An ingress  describes a load balancer operating at the edge of the mesh that receives incoming HTTP/TCP connections. It configures exposed ports, protocols, etc. but, unlike , does not include any traffic routing configuration. Traffic routing for ingress traffic is instead configured using Istio routing rules, exactly in the same way as for internal service requests.Let’s see how you can configure a  on port 80 for HTTP traffic.Create an Istio :Configure routes for traffic entering via the :You have now created a configuration for the  service containing two route rules that allow traffic for paths  and .The  list specifies that only requests through your  are allowed. All other external requests will be rejected with a 404 response.Access the  service using :Note that you use the  flag to set the  HTTP header to “httpbin.example.com”. This is needed because your ingress  is configured to handle “httpbin.example.com”, but in your test environment you have no DNS binding for that host and are simply sending your request to the ingress IP.Access any other URL that has not been explicitly exposed. You should see an HTTP 404 error:Entering the  service URL in a browser won’t work because you can’t pass the  header to a browser like you did with . In a real world situation, this is not a problem because you configure the requested host properly and DNS resolvable. Thus, you use the host’s domain name in the URL, for example, .To work around this problem for simple tests and demos, use a wildcard  value for the host in the and  configurations. For example, if you change your ingress configuration to the following:You can then use  in the browser URL. For example, will display all the headers that your browser sends.The  configuration resources allow external traffic to enter the Istio service mesh and make the traffic management and policy features of Istio available for edge services.In the preceding steps, you created a service inside the service mesh and exposed an HTTP endpoint of the service to external traffic.Inspect the values of the  and  environment variables. Make sure they have valid values, according to the output of the following commands:Check that you have no other Istio ingress gateways defined on the same port:Check that you have no Kubernetes Ingress resources defined on the same IP and port:If you have an external load balancer and it does not work for you, try to .Delete the  and  configuration, and shutdown the  service:Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Configure Istio ingress gateway to act as a proxy for external services.Describes how to deploy a custom ingress gateway using cert-manager manually.Describes how to configure Istio ingress with a network load balancer on AWS.How to configure gateway network topology.Describes how to configure a Kubernetes Ingress object to expose a service outside of the service mesh.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  The  task describes how to configure HTTPS ingress access to an HTTP service. This example describes how to configure HTTPS ingress access to an HTTPS service, i.e., configure an ingress gateway to perform SNI passthrough, instead of TLS termination on incoming requests.The example HTTPS service used for this task is a simple  server. In the following steps you first deploy the NGINX service in your Kubernetes cluster. Then you configure a gateway to provide ingress access to the service via host .For this task you can use your favorite tool to generate certificates and keys. The commands below use Create a root certificate and private key to sign the certificate for your services:Create a certificate and a private key for :Create a Kubernetes  to hold the server’s certificate.Create a configuration file for the NGINX server:Create a Kubernetes to hold the configuration of the NGINX server:Deploy the NGINX server:To test that the NGINX server was deployed successfully, send a request to the server from its sidecar proxy without checking the server’s certificate (use the  option of ). Ensure that the server’s certificate is printed correctly, i.e.,  is equal to .Define a  with a  section for port 443. Note the  TLS mode which instructs the gateway to pass the ingress traffic AS IS, without terminating TLS.Configure routes for traffic entering via the :Follow the instructions in  to define the  and  environment variables.Access the NGINX service from outside the cluster. Note that the correct certificate is returned by the server and it is successfully verified ( is printed).Remove created Kubernetes resources:Delete the certificates and keys:Delete the generated configuration files used in this example:Configure Istio ingress gateway to act as a proxy for external services.Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Describes how to deploy a custom ingress gateway using cert-manager manually.Describes how to configure Istio ingress with a network load balancer on AWS.Describes a simple scenario based on Istio's Bookinfo example.How to configure gateway network topology.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task describes how to configure Istio to expose a service outside of the service mesh cluster, using the Kubernetes .Follow the instructions in the  and  sections of the .A  exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.Let’s see how you can configure a  on port 80 for HTTP traffic.Create an  resource:The  annotation is required to tell the Istio gateway controller that it should handle this , otherwise it will be ignored.Access the  service using :Note that you use the  flag to set the  HTTP header to “httpbin.example.com”. This is needed because the  is configured to handle “httpbin.example.com”, but in your test environment you have no DNS binding for that host and are simply sending your request to the ingress IP.Access any other URL that has not been explicitly exposed. You should see an HTTP 404 error: supports . This is supported by Istio, but the referenced  must exist in the namespace of the  deployment (typically ).  can be used to generate these certificates.By default, Istio will treat paths as exact matches, unless they end in  or , in which case they will become prefix matches. Other regular expressions are not supported.In Kubernetes 1.18, a new field, , was added. This allows explicitly declaring a path as  or .In Kubernetes 1.18, a new resource, , was added, replacing the  annotation on the  resource. If you are using this resource, you will need to set the  field to . For example:Delete the  configuration, and shutdown the  service:Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Configure Istio ingress gateway to act as a proxy for external services.Describes how to deploy a custom ingress gateway using cert-manager manually.Describes how to configure Istio ingress with a network load balancer on AWS.How to configure gateway network topology.Describes how to configure SNI passthrough for an ingress gateway.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  The describes how to configure an ingress gateway to expose an HTTP service to external traffic. This task shows how to expose a secure HTTPS service using either simple or mutual TLS.Perform the steps in the . and sections of the  task. After performing those steps you should have Istio and the  service deployed, and the environment variables  and  set.For macOS users, verify that you use  compiled with the  library:If the previous command outputs a version of LibreSSL as shown, your  command should work correctly with the instructions in this task. Otherwise, try a different implementation of , for example on a Linux machine.For this task you can use your favorite tool to generate certificates and keys. The commands below use Create a root certificate and private key to sign the certificates for your services:Create a certificate and a private key for :Ensure you have deployed the  service from .Create a secret for the ingress gateway:Define a gateway with a  section for port 443, and specify values for to be . The values are the same as the secret’s name. The TLS mode should have the value of .Configure the gateway’s ingress traffic routes. Define the corresponding virtual service.Send an HTTPS request to access the  service through HTTPS:The  service will return the code.Delete the gateway’s secret and create a new one to change the ingress gateway’s credentials.Access the  service using  using the new certificate chain:If you try to access  with the previous certificate chain, the attempt now fails.You can configure an ingress gateway for multiple hosts, and , for example. The ingress gateway retrieves unique credentials corresponding to a specific .To restore the credentials for , delete its secret and create it again.Start the  sampleGenerate a certificate and a private key for :Create the  secret:Define a gateway with two server sections for port 443. Set the value of on each port to  and respectively. Set TLS mode to .Configure the gateway’s traffic routes. Define the corresponding virtual service.Send an HTTPS request to :Send an HTTPS request to  and still get a teapot in return:You can extend your gateway’s definition to support . Change the credentials of the ingress gateway by deleting its secret and creating a new one. The server uses the CA certificate to verify its clients, and we must use the name  to hold the CA certificate.Change the gateway’s definition to set the TLS mode to .Attempt to send an HTTPS request using the prior approach and see how it fails:Generate client certificate and private key:Pass a client certificate and private key to  and resend the request. Pass your client’s certificate with the  flag and your private key with the  flag to .Istio supports reading a few different Secret formats, to support integration with various tools such as :Inspect the values of the  and  environment variables. Make sure they have valid values, according to the output of the following commands:Check the log of the  controller for error messages:If using macOS, verify you are using  compiled with the library, as described in the  section.Verify that the secrets are successfully created in the namespace: and  should show in the secrets list.Check the logs to verify that the ingress gateway agent has pushed the key/certificate pair to the ingress gateway.The log should show that the  secret was added. If using mutual TLS, then the  secret should also appear. Verify the log shows that the gateway agent receives SDS requests from the ingress gateway, that the resource’s name is , and that the ingress gateway obtained the key/certificate pair. If using mutual TLS, the log should show key/certificate was sent to the ingress gateway, that the gateway agent received the SDS request with the resource name, and that the ingress gateway obtained the root certificate.Delete the gateway configuration, the virtual service definition, and the secrets:Delete the certificates and keys:Shutdown the  and  services:Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Configure Istio ingress gateway to act as a proxy for external services.Describes how to deploy a custom ingress gateway using cert-manager manually.Describes how to configure Istio ingress with a network load balancer on AWS.How to configure gateway network topology.Describes how to configure a Kubernetes Ingress object to expose a service outside of the service mesh.Istio 1.8© 2020 Istio Authors, Page last modified: July 17, 2020  This task demonstrates the traffic mirroring capabilities of Istio.Traffic mirroring, also called shadowing, is a powerful concept that allows feature teams to bring changes to production with as little risk as possible. Mirroring sends a copy of live traffic to a mirrored service. The mirrored traffic happens out of band of the critical request path for the primary service.In this task, you will first force all traffic to  of a test service. Then, you will apply a rule to mirror a portion of traffic to .Set up Istio by following the instructions in the .Start by deploying two versions of the  service that have access logging enabled:Start the  service so you can use  to provide load:By default Kubernetes load balances across both versions of the  service. In this step, you will change that behavior so that all traffic goes to .Create a default route rule to route all traffic to  of the service:Now all traffic goes to the  service.Send some traffic to the service:Check the logs for  and  of the  pods. You should see access log entries for  and none for :Change the route rule to mirror traffic to v2:This route rule sends 100% of the traffic to . The last stanza specifies that you want to mirror to the  service. When traffic gets mirrored, the requests are sent to the mirrored service with their Host/Authority headers appended with . For example,  becomes .Also, it is important to note that these requests are mirrored as “fire and forget”, which means that the responses are discarded.You can use the  field to mirror a fraction of the traffic, instead of mirroring all requests. If this field is absent, for compatibility with older versions, all traffic will be mirrored.Send in traffic:Now, you should see access logging for both  and . The access logs created in  are the mirrored requests that are actually going to .Remove the rules:Shutdown the  service and client:An introduction to safer, lower-risk deployments and release to production.Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Automating Istio configuration for Istio deployments (clusters) that work as a single mesh.Configure Istio ingress gateway to act as a proxy for external services.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Comparison of alternative solutions to control egress traffic including performance considerations.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task shows you how to route requests dynamically to multiple versions of a microservice.Setup Istio by following the instructions in the .Deploy the  sample application.Review the  concepts doc. Before attempting this task, you should be familiar with important terms such as , , and .The Istio  sample consists of four separate microservices, each with multiple versions. Three different versions of one of the microservices, , have been deployed and are running concurrently. To illustrate the problem this causes, access the Bookinfo app’s  in a browser and refresh several times. You’ll notice that sometimes the book review output contains star ratings and other times it does not. This is because without an explicit default service version to route to, Istio routes requests to all available versions in a round robin fashion.The initial goal of this task is to apply rules that route all traffic to  (version 1) of the microservices. Later, you will apply a rule to route traffic based on the value of an HTTP request header.To route to one version only, you apply virtual services that set the default version for the microservices. In this case, the virtual services will route all traffic to  of each microservice.Run the following command to apply the virtual services:Because configuration propagation is eventually consistent, wait a few seconds for the virtual services to take effect.Display the defined routes with the following command:You can also display the corresponding  definitions with the following command:You have configured Istio to route to the  version of the Bookinfo microservices, most importantly the  service version 1.You can easily test the new configuration by once again refreshing the of the Bookinfo app.Open the Bookinfo site in your browser. The URL is , where  is the External IP address of the ingress, as explained in the  doc.Notice that the reviews part of the page displays with no rating stars, no matter how many times you refresh. This is because you configured Istio to route all traffic for the reviews service to the version  and this version of the service does not access the star ratings service.You have successfully accomplished the first part of this task: route traffic to one version of a service.Next, you will change the route configuration so that all traffic from a specific user is routed to a specific service version. In this case, all traffic from a user named Jason will be routed to the service .Note that Istio doesn’t have any special, built-in understanding of user identity. This example is enabled by the fact that the  service adds a custom  header to all outbound HTTP requests to the reviews service.Remember,  is the version that includes the star ratings feature.Run the following command to enable user-based routing:Confirm the rule is created:On the  of the Bookinfo app, log in as user .Refresh the browser. What do you see? The star ratings appear next to each review.Log in as another user (pick any name you wish).Refresh the browser. Now the stars are gone. This is because traffic is routed to  for all users except Jason.You have successfully configured Istio to route traffic based on user identity.In this task, you used Istio to send 100% of the traffic to the  version of each of the Bookinfo services. You then set a rule to selectively send traffic to version  of the  service based on a custom  header added to the request by the  service.Note that Kubernetes services, like the Bookinfo ones used in this task, must adhere to certain restrictions to take advantage of Istio’s L7 routing features. Refer to the  for details.In the  task, you will follow the same basic pattern you learned here to configure route rules to gradually send traffic from one version of a service to another.Remove the application virtual services:If you are not planning to explore any follow-on tasks, refer to the instructions to shutdown the application.Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Automating Istio configuration for Istio deployments (clusters) that work as a single mesh.Configure Istio ingress gateway to act as a proxy for external services.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020  This task shows you how to setup request timeouts in Envoy using Istio.Setup Istio by following the instructions in the .Deploy the  sample application including the .Initialize the application version routing by running the following command:A timeout for HTTP requests can be specified using the  field of the . By default, the request timeout is disabled, but in this task you override the  service timeout to 1 second. To see its effect, however, you also introduce an artificial 2 second delay in calls to the  service.Route requests to v2 of the  service, i.e., a version that calls the  service:Add a 2 second delay to calls to the  service:Open the Bookinfo URL  in your browser.You should see the Bookinfo application working normally (with ratings stars displayed), but there is a 2 second delay whenever you refresh the page.Now add a half second request timeout for calls to the  service:Refresh the Bookinfo web page.You should now see that it returns in about 1 second, instead of 2, and the reviews are unavailable.In this task, you used Istio to set the request timeout for calls to the microservice to half a second. By default the request timeout is disabled. Since the  service subsequently calls the  service when handling requests, you used Istio to inject a 2 second delay in calls to  to cause the service to take longer than half a second to complete and consequently you could see the timeout in action.You observed that instead of displaying reviews, the Bookinfo product page (which calls the  service to populate the page) displayed the message: Sorry, product reviews are currently unavailable for this book. This was the result of it receiving the timeout error from the  service.If you examine the , you’ll find out that the microservice also has its own application-level timeout (3 seconds) for calls to the  microservice. Notice that in this task you used an Istio route rule to set the timeout to half a second. Had you instead set the timeout to something greater than 3 seconds (such as 4 seconds) the timeout would have had no effect since the more restrictive of the two takes precedence. More details can be found .One more thing to note about timeouts in Istio is that in addition to overriding them in route rules, as you did in this task, they can also be overridden on a per-request basis if the application adds an  header on outbound requests. In the header, the timeout is specified in milliseconds instead of seconds.Remove the application routing rules:If you are not planning to explore any follow-on tasks, see the instructions to shutdown the application.Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Automating Istio configuration for Istio deployments (clusters) that work as a single mesh.Configure Istio ingress gateway to act as a proxy for external services.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: August 21, 2020  This task shows you how to gradually migrate traffic from one version of a microservice to another. For example, you might migrate traffic from an older version to a new version.A common use case is to migrate traffic gradually from one version of a microservice to another. In Istio, you accomplish this goal by configuring a sequence of rules that route a percentage of traffic to one service or another. In this task, you will send 50% of traffic to  and 50% to . Then, you will complete the migration by sending 100% of traffic to .Setup Istio by following the instructions in the .Deploy the  sample application.Review the  concepts doc.To get started, run this command to route all traffic to the  version of each microservice.Open the Bookinfo site in your browser. The URL is , where  is the External IP address of the ingress, as explained in the  doc.Notice that the reviews part of the page displays with no rating stars, no matter how many times you refresh. This is because you configured Istio to route all traffic for the reviews service to the version  and this version of the service does not access the star ratings service.Transfer 50% of the traffic from  to  with the following command:Wait a few seconds for the new rules to propagate.Confirm the rule was replaced:Refresh the  in your browser and you now see  colored star ratings approximately 50% of the time. This is because the  version of  accesses the star ratings service, but the  version does not.Assuming you decide that the  microservice is stable, you can route 100% of the traffic to  by applying this virtual service:Now when you refresh the  you will always see book reviews with  colored star ratings for each review.In this task you migrated traffic from an old to new version of the  service using Istio’s weighted routing feature. Note that this is very different than doing version migration using the deployment features of container orchestration platforms, which use instance scaling to manage the traffic.With Istio, you can allow the two versions of the  service to scale up and down independently, without affecting the traffic distribution between them.For more information about version routing with autoscaling, check out the blog article .Remove the application routing rules:If you are not planning to explore any follow-on tasks, refer to the instructions to shutdown the application.Configure the IBM Cloud Kubernetes Service Application Load Balancer to direct traffic to the Istio Ingress gateway with mutual TLS.Automating Istio configuration for Istio deployments (clusters) that work as a single mesh.Configure Istio ingress gateway to act as a proxy for external services.Deploy environments that require isolation into separate meshes and enable inter-mesh communication by mesh federation.Comparison of alternative solutions to control egress traffic including performance considerations.Use Istio Egress Traffic Control to prevent attacks involving egress traffic.Istio 1.8© 2020 Istio Authors, Page last modified: July 15, 2020